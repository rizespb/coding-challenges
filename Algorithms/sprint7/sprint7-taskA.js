// ID успешной посылки 103898351

/*
-- ПРИНЦИП РАБОТЫ --

Создаем матрицу для хранения промежуточных результатов, размером (длина первой строки + 1) х (длина второй строки +1).
В ячейке [0][0] будет располагаться базовый случай для двух пустых строк: расстояние Левенштейна для пустых строк равно нулю. 
В первом столбце будут располагаться разницы между подстроками первой строки от 0 до i первой строки и пустой строкой (как частного случая подстроки второй строки). Разница между подстрокой 'abc...' и пустой строкой '' равна длине подстроки.
Аналогично для первой строки заполняем разницу между подстроками второй строки от 0 до j первой строки и пустой строкой (как частного случая подстроки первой строки).

Далее начинаем последовательно вычислять расстояние между подстрокаки первой (подсткрока от 0 до i) и второй строки (подстрока от 0 до j) на основе ранее вычисленных значений.
Если символы в ячейке [i][j] равны, тогда мы ничего не делаем и берем накопленное расстояние из [i-1][j-1], вычисленное для подстрок до предыдущего символа
Если символы не равны, то мы выбираем, что "дешевле":
Удалить символ (берем значение из [i-1][j] и выполняем удаление +1)
Вставить символ (взять значение из [i][j-1] и выполняем вставку +1)
Заменить символ (взять значение из [i-1][j-1] и выполняем замену +1)

Результат будет находится в правой нижней ячейке матрицы

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность составляет O(N ⋅ M), где
N - число символов в первой строке
M - число символов во второй строке

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O((N + 1) ⋅ (M + 1)) для хранения массива dp

*/

const _readline = require('readline');

const _reader = _readline.createInterface({
  input: process.stdin,
});

const _inputLines = [];

_reader.on('line', (line) => {
  _inputLines.push(line);
});

process.stdin.on('end', solve);

const createDp = (str1, str2) => {
  const dp = new Array(str1.length + 1).fill(Infinity).map(() => new Array(str2.length + 1).fill(-1));

  for (let i = 0; i <= str1.length; i++) {
    dp[i][0] = i;
  }

  for (let i = 0; i <= str2.length; i++) {
    dp[0][i] = i;
  }

  return dp;
};

const getDistance = (str1, str2) => {
  const dp = createDp(str1, str2);

  for (let i = 1; i <= str1.length; i++) {
    const str1Char = str1[i - 1];

    for (let j = 1; j <= str2.length; j++) {
      const str2Char = str2[j - 1];

      if (str1Char === str2Char) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
      }
    }
  }

  return dp[str1.length][str2.length];
};

function solve() {
  const str1 = _inputLines[0];
  const str2 = _inputLines[1];

  const result = getDistance(str1, str2);

  console.log(result);
}
