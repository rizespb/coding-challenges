// ID успешной посылки 95485250

/*
-- ПРИНЦИП РАБОТЫ --

За основу решения программы я взял бинарный поиск.

Нюанс состоит в том, что массив «был сломан» и мы не можем однозначно определить принадлежность элемента к какой-то части массива (левой или правой). Но мы можем утверждать, что при выборе любого опорного элемента мы получаем два массива, один из которых точно отсортирован.

Мы определяем отсотированную часть массива. И теперь мы можем однозначно определить, принадлежит ли элемент этой части массива. Если искомый элемент не равен опорному и находится не в отсортированной части, значит он находится в другой части массива.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Сортировка осуществляется со сложносью О(log n) - сложность алгоритма бинарного поиска

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Алгоритм сортируем элементы «на месте».
Поэтому программа будет потреблять O(1) дополнительной памяти.
*/

function brokenSearch(arr, k) {
  let start = 0
  let end = arr.length - 1

  while (start <= end) {
    let middle = Math.floor((start + end) / 2)

    const firstEl = arr[start]
    const middleEl = arr[middle]
    const lastEl = arr[end]

    if (middleEl === k) {
      return middle
    }

    if (firstEl <= middleEl) {
      if (firstEl <= k && k < middleEl) {
        end = middle - 1
      } else {
        start = middle + 1
      }
    } else {
      if (middleEl < k && k <= lastEl) {
        start = middle + 1
      } else {
        end = middle - 1
      }
    }
  }

  return -1
}

function test() {
  const arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
  if (brokenSearch(arr, 5) !== 6) {
    console.error('WA')
  }
}
