# Задача: Оптимизация рендеринга компонентов

## Описание
Есть компонент со стейтом и дургим вложенным компонентом.
Изучи код:
- что произойдёт при клике на кнопку "Increment Counter"?
- к каким негативным последствия могут приводить лишние перерисовки интерфейса?
- какие инструменты можно использовать для анализа производительности и ререндеров?
- какие есть подходы для предотвращения излишних перерисовок?
- напиши исправления

## Код задачи
```jsx
import React, { useState } from 'react';

// Дочерний компонент с ресурсоемкими операциями
const ChildComponent = ({ data }) => {
  // Сложные вычисления и отображение большого объема данных
  return <div>{JSON.stringify(data)}</div>;
};

// Родительский компонент
const ParentComponent = ({ data }) => {
  const [counter, setCounter] = useState(0);

  const handleClick = () => {
    setCounter(counter + 1);
  };

  return (
    <>
      <button onClick={handleClick}>Increment Counter</button>
      <ChildComponent data={data} />
    </>
  );
};
```

## Ответы и решения

**Что произойдёт при клике на кнопку "Increment Counter"?**
1. Происходит вызов метода handleClick(), который увеличивает значение переменной counter на единицу.
2. Изменяется локальное состояние компонента ParentComponent посредством вызова setCounter().
3. Компонент ParentComponent повторно рендерится из-за изменения своего состояния.
3. Все дочерние компоненты, также повторно рендерятся независимо от того, изменились ли их пропсы.
4. Несмотря на то, что пропс data в ChildComponent не изменился, компонент все равно рендерится заново.

**К каким негативным последствия могут приводить лишние перерисовки интерфейса?**
1. Повторный расчет и рендеринг компонентов, чьи данные не изменились, тратят процессорное время впустую.
2. Частые перерисовки могут привести к снижению отзывчивости приложения.
3. Может быть критично для старых устройств с ограниченными ресурсами.

**Какие инструменты можно использовать для анализа производительности и ререндеров?**
1. React Developer Tools: позволяет визуально наблюдать за деревом компонентов и изменениями их состояния.
2. Браузерные DevTools: позволяют детально анализировать работу приложения, включая загрузку CPU и память.
3. Why Did You Render: Библиотека, которая отслеживает причины рендеринга компонентов и предупреждает о потенциально избыточных обновлениях.
4. Инструменты мониторинга: специальные инструменты, работающие в продакшене, например Sentry или Datadog.

**Какие есть подходы для предотвращения излишних перерисовок?**
1. Мемоизация с помощью React.memo: позволяет компонету пропускать повторный рендеринг, если его пропсы не изменились.
2. Мемоизация функций с useCallback: сохраняет ссылку на функцию между рендерами, уменьшая вероятность ненужных обновлений дочерних компонентов.
3. Мемоизация значений с useMemo: кэширует результаты дорогостоящих вычислений, что позволяет избегать их повторного выполнения.
4. Специальные решения, например виртуализированные списки.

**Код возможного решения**
```jsx
import React, { useState, memo } from 'react';

// Оборачиваем ChildComponent в memo()
const ChildComponent = memo(({ data }) => {
  // Сложные вычисления и отображение большого объема данных
  return <div>{JSON.stringify(data)}</div>;
});

// Родительский компонент остается без изменений
const ParentComponent = ({ data }) => {
  const [counter, setCounter] = useState(0);

  const handleClick = () => {
    setCounter(counter + 1);
  };

  return (
    <>
      <button onClick={handleClick}>Increment Counter</button>
      <ChildComponent data={data} />
    </>
  );
};
```
